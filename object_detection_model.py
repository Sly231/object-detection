# -*- coding: utf-8 -*-
"""Object Detection Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1htka8b5I_rPrlg0B2ZlssXJA2ay25QNp
"""

pip install tensorflow

pip install --upgrade tensorflow-hub

import tensorflow as tf
import tensorflow_hub as hub
import numpy as np
import cv2
import os
from google.colab.patches import cv2_imshow

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Load the Object Detection model from TensorFlow Hub
model_url = 'https://tfhub.dev/tensorflow/efficientdet/d4/1'
model = hub.load(model_url)

# Load and preprocess the image
image_path = '/content/image.jpg'  # Replace with the actual absolute path to your image

try:
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Failed to load image at '{image_path}'")
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    input_image = np.expand_dims(image_rgb, axis=0)
    input_image = input_image / 255.0

    # Perform object detection using the model
    with tf.device('/CPU:0'):
        outputs = model(input_image)
    detections = outputs['detection_scores'][0].numpy()
    labels = outputs['detection_classes'][0].numpy()  # Change 'detection_class_entities' to 'detection_classes'
    boxes = outputs['detection_boxes'][0].numpy()

    # Post-process the detections
    threshold = 0.5
    filtered_detections = [label.decode() for label, score in zip(labels, detections) if score >= threshold]

    # Display the results
    for label in filtered_detections:
        print(label)

    # Draw bounding boxes on the image
    for box in boxes:
        ymin, xmin, ymax, xmax = box
        ymin = int(ymin * image.shape[0])
        xmin = int(xmin * image.shape[1])
        ymax = int(ymax * image.shape[0])
        xmax = int(xmax * image.shape[1])
        cv2.rectangle(image, (xmin, ymin), (xmax, ymax), (0, 255, 0), 2)

    # Show the image with bounding boxes
    cv2_imshow(image)
    cv2.waitKey(0)

except Exception as e:
    print(f"Error: {e}")

import tensorflow as tf
import tensorflow_hub as hub
import numpy as np
import cv2
import os
from google.colab.patches import cv2_imshow
import logging
import warnings

warnings.filterwarnings("ignore")
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

# Suppress TensorFlow warning messages
tf.get_logger().setLevel(logging.ERROR)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

# Suppress TensorFlow Hub specific warnings
warnings.filterwarnings("ignore", category=UserWarning, message=".*?Your CPU supports instructions that this TensorFlow binary was not compiled to use.*?")
warnings.filterwarnings("ignore", category=UserWarning, message=".*?\[absl\].*?Importing a function \(__inference_.*? with ops with unsaved custom gradients.*?")

# Load the Object Detection model from TensorFlow Hub
model_url = 'https://tfhub.dev/tensorflow/efficientdet/d4/1'
model = hub.load(model_url)

# Load and preprocess the image
image_path = '/content/image.jpg'  # Replace with the actual absolute path to your image

try:
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Failed to load image at '{image_path}'")
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    input_image = np.expand_dims(image_rgb, axis=0)
    input_image = input_image / 255.0

    # Perform object detection using the model
    with tf.device('/CPU:0'):
        outputs = model(input_image)
    detections = outputs['detection_scores'][0].numpy()
    labels = outputs['detection_classes'][0].numpy()  # Change 'detection_class_entities' to 'detection_classes'
    boxes = outputs['detection_boxes'][0].numpy()

    # Post-process the detections
    threshold = 0.5
    filtered_detections = [label.decode() for label, score in zip(labels, detections) if score >= threshold]

    # Display the results
    for label in filtered_detections:
        print(label)

    # Draw bounding boxes on the image
    for box in boxes:
        ymin, xmin, ymax, xmax = box
        ymin = int(ymin * image.shape[0])
        xmin = int(xmin * image.shape[1])
        ymax = int(ymax * image.shape[0])
        xmax = int(xmax * image.shape[1])
        cv2.rectangle(image, (xmin, ymin), (xmax, ymax), (0, 255, 0), 2)

    # Show the image with bounding boxes
    cv2_imshow(image)
    cv2.waitKey(0)

except Exception as e:
    print(f"Error: {e}")